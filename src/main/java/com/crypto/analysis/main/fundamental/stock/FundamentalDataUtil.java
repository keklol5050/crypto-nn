package com.crypto.analysis.main.fundamental.stock;import com.crypto.analysis.main.data_utils.enumerations.TimeFrame;import com.crypto.analysis.main.fundamental.stock.enumerations.FundamentalStock;import com.crypto.analysis.main.fundamental.stock.enumerations.FundamentalTimeFrame;import com.crypto.analysis.main.fundamental.stock.enumerations.TimeFrameConverter;import com.crypto.analysis.main.vo.CandleObject;import com.fasterxml.jackson.databind.JsonNode;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import java.io.BufferedInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.net.URL;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;import static com.crypto.analysis.main.data_utils.BinanceDataUtil.objectMapper;public class FundamentalDataUtil {    private static final OkHttpClient client = new OkHttpClient();    private static final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    static {        sdf.setTimeZone(TimeZone.getTimeZone("UTC+0"));    }    private static final String key = "4bb2e7eb9fe24d8d907287b30ae5eb4b";    private final FundamentalTimeFrame interval;    private final int capacity;    private TreeMap<Date, Double> SPX;    private TreeMap<Date, Double> DXY;    private TreeMap<Date, Double> DJI;    private TreeMap<Date, Double> VIX;    private TreeMap<Date, Double> NDX;    private TreeMap<Date, Double> GOLD;    public FundamentalDataUtil(int capacity, TimeFrame interval) {        this.interval = TimeFrameConverter.convert(interval);        this.capacity = capacity;        init();    }    private void init() {        SPX = getData(FundamentalStock.SPX, capacity, interval);        DXY = getData(FundamentalStock.DXY, capacity, interval);        DJI = getData(FundamentalStock.DJI, capacity, interval);        VIX = getData(FundamentalStock.VIX, capacity, interval);        NDX = getData(FundamentalStock.NDX, capacity, interval);        GOLD = getData(FundamentalStock.GOLD, capacity, interval);    }    public FundamentalStockObject getFundamentalData(CandleObject coinCandle) {        FundamentalStockObject result = new FundamentalStockObject(interval);        result.setSPX(SPX.floorEntry(coinCandle.getOpenTime()).getValue());        result.setDXY(DXY.floorEntry(coinCandle.getOpenTime()).getValue());        result.setDJI(DJI.floorEntry(coinCandle.getOpenTime()).getValue());        result.setVIX(VIX.floorEntry(coinCandle.getOpenTime()).getValue());        result.setNDX(NDX.floorEntry(coinCandle.getOpenTime()).getValue());        result.setGOLD(GOLD.floorEntry(coinCandle.getOpenTime()).getValue());        return result;    }    public static TreeMap<Date,Double> getData(FundamentalStock symbol, int capacity, FundamentalTimeFrame interval) {        capacity+=10;        if (capacity > 5000) throw new IllegalArgumentException("Count capacity must be less than 5000");        String url = String.format("https://api.twelvedata.com/time_series?symbol=%s&timezone=UTC&outputsize=%s&interval=%s&apikey=%s",                symbol.getName(), capacity, interval.getTimeFrame(), key);        Request request = new Request.Builder()                .url(url)                .build();        TreeMap<Date, Double> result = new TreeMap<>();        try {            Response response = client.newCall(request).execute();            if (response.isSuccessful()) {                assert response.body() != null;                String jsonData = response.body().string();                JsonNode root = objectMapper.readTree(jsonData);                JsonNode valuesNode = root.get("values");                for (JsonNode node : valuesNode) {                    Date openTime = sdf.parse(node.get("datetime").asText());                    double open = node.get("open").asDouble();                    result.put(openTime, open);                }            } else {                System.out.println("Error: " + response.code() + " " + response.message());            }            response.close();        } catch (IOException | ParseException e) {            e.printStackTrace(System.out);        }        return result;    }}